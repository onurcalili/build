diff --git a/drivers/char/tpm/tpm_tis_spi.c b/drivers/char/tpm/tpm_tis_spi.c
index 19513e622..2ab649824 100644
--- a/drivers/char/tpm/tpm_tis_spi.c
+++ b/drivers/char/tpm/tpm_tis_spi.c
@@ -61,6 +61,8 @@ static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 	u8 transfer_len;
 
 	spi_bus_lock(phy->spi_device->master);
+	
+	pr_err("inside tpm_tis_spi_transfer\n");
 
 	while (len) {
 		transfer_len = min_t(u16, len, MAX_SPI_FRAMESIZE);
@@ -79,8 +81,10 @@ static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 		spi_message_init(&m);
 		spi_message_add_tail(&spi_xfer, &m);
 		ret = spi_sync_locked(phy->spi_device, &m);
-		if (ret < 0)
+		if (ret < 0) {
+			pr_err("inside tpm_tis_spi_transfer 2\n");
 			goto exit;
+		}
 
 		if ((phy->iobuf[3] & 0x01) == 0) {
 			// handle SPI wait states
@@ -91,13 +95,16 @@ static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 				spi_message_init(&m);
 				spi_message_add_tail(&spi_xfer, &m);
 				ret = spi_sync_locked(phy->spi_device, &m);
-				if (ret < 0)
+				if (ret < 0) {
+					pr_err("inside tpm_tis_spi_transfer 3\n");
 					goto exit;
+				}
 				if (phy->iobuf[0] & 0x01)
 					break;
 			}
 
 			if (i == TPM_RETRY) {
+				pr_err("inside tpm_tis_spi_transfer 4\n");
 				ret = -ETIMEDOUT;
 				goto exit;
 			}
@@ -118,8 +125,10 @@ static int tpm_tis_spi_transfer(struct tpm_tis_data *data, u32 addr, u16 len,
 		spi_message_init(&m);
 		spi_message_add_tail(&spi_xfer, &m);
 		ret = spi_sync_locked(phy->spi_device, &m);
-		if (ret < 0)
+		if (ret < 0) {
+			pr_err("inside tpm_tis_spi_transfer 5\n");
 			goto exit;
+		}
 
 		if (in) {
 			memcpy(in, phy->iobuf, transfer_len);
@@ -196,26 +205,41 @@ static int tpm_tis_spi_probe(struct spi_device *dev)
 {
 	struct tpm_tis_spi_phy *phy;
 	int irq;
+	int ret;
+
+	dev_info(&dev->dev, "probing");
 
 	phy = devm_kzalloc(&dev->dev, sizeof(struct tpm_tis_spi_phy),
 			   GFP_KERNEL);
 	if (!phy)
 		return -ENOMEM;
 
+	dev_info(&dev->dev, "probed");
+
 	phy->spi_device = dev;
 
 	phy->iobuf = devm_kmalloc(&dev->dev, MAX_SPI_FRAMESIZE, GFP_KERNEL);
 	if (!phy->iobuf)
 		return -ENOMEM;
 
+	dev_info(&dev->dev, "iobuffer allocated");
+
 	/* If the SPI device has an IRQ then use that */
-	if (dev->irq > 0)
+	if (dev->irq > 0) {
+		dev_info(&dev->dev, "has irq : %d", dev->irq);
 		irq = dev->irq;
-	else
+	}
+	else {
 		irq = -1;
+		dev_info(&dev->dev, "has no irq");
+	}
 
-	return tpm_tis_core_init(&dev->dev, &phy->priv, irq, &tpm_spi_phy_ops,
+	ret = tpm_tis_core_init(&dev->dev, &phy->priv, irq, &tpm_spi_phy_ops,
 				 NULL);
+	
+	dev_info(&dev->dev, "init ret : %d", ret);
+
+	return ret;
 }
 
 static SIMPLE_DEV_PM_OPS(tpm_tis_pm, tpm_pm_suspend, tpm_tis_resume);
